<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>Delivery truck</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>
    <script src='https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js'></script>
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.2/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.2/mapbox-gl.css' rel='stylesheet'/>
    <style>
        body {margin: 0; padding: 0;}

        tr:nth-child(even) {background-color: #dddddd;}
        
        table {
            font-family: arial, sans-serif;
            border-collapse: collapse;
            width: 100%;
        }

        td{
            border: 1px solid #dddddd;
            text-align: left;
            padding: 8px;
            cursor:context-menu;
        }
        th {
            border: 1px solid #dddddd;
            text-align: left;
            padding: 8px;
            cursor:pointer;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            right: 0;
            left: 0;
        }
        
        .truck {
            margin: -10px -10px;
            width: 20px;
            height: 20px;
            border: 2px solid #fff;
            border-radius: 50%;
            background: #3887BE;
            cursor: pointer;
        }
        
        .button {
           background-color: #4CAF50;
           border: none;
           color: white;
           padding: 15px 135px;
           text-align: center;
           text-decoration: none;
           display: inline-block;
           font-size: 16px;
           margin: 4px 2px;
           cursor: pointer;
        }
        
        .back {
            font-family: arial;
            border-collapse: collapse;
            width: 100%;
            padding: 20px 40px; 
        }
        
        .mapboxgl-popup {max-width: 200px;}

        .mapboxgl-popup-content {
          text-align: center;
          font-family: 'Open Sans', sans-serif;
        }
        
        .map-overlay {
          position: absolute;
          bottom: 0;
          left: 0;
          background: rgba(255, 255, 255, 1.0);
          margin-left: auto;
          font-family: Arial, sans-serif;
          overflow: auto;
          border-radius: 3px;
        }

        #features {
          top: 0;
          height: 640px;
        }
        
        .previous {
            background-color: #f1f1f1;
            color: black;
        }

        .dot {
            height: 10px;
            width: 10px;
            background-color: #735139;
            border-radius: 50%;
            display: inline-block;
        }
    </style>
</head>
<body>
    <style>
        .legend {
            background-color: #fff;
            border-radius: 3px;
            bottom: 30px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.10);
            font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
            padding: 10px;
            position: absolute;
            right: 10px;
            z-index: 1;
        }

        .legend h4 {margin: 0 0 10px;}

        .legend div span {
            border-radius: 50%;
            display: inline-block;
            height: 15px;
            margin-right: 5px;
            width: 15px;
        }
    </style>
    
    <div id='marker-legend' class='legend'>
        <h4>Markers</h4>
        <div><span><svg width="10" height="10"><rect width="10" height="10" style="fill:#735139" /></svg></span>Unmarked Dropoff</div>
        <div><span><svg width="10" height="10"><circle cx="5" cy="5" r="5" style="fill:#735139"  /></svg></span>Marked Dropoff</div>
        <div><span><svg width="10" height="10"><circle cx="5" cy="5" r="5" style="fill:#3887BE"  /></svg></span>Truck</div>
    </div>
    
    <div id='map' class='contain'> </div>
    <div class='map-overlay' id='features'>
    <div id='pd'></div></div>
    <script type="text/javascript">

        // *********************************************************************
        // Mapbox
        // *********************************************************************

        // Load initial map
        // *********************************************************************
        mapboxgl.accessToken = 'pk.eyJ1IjoidG9ybGFuY28iLCJhIjoiY2prYmR3dmszMHVtcDNwbWl3cHdwOTl5NSJ9.NxympEZmljc0jq4DJmK5JQ';

        var map = new mapboxgl.Map({
            container: 'map', // container id
            style: 'mapbox://styles/mapbox/streets-v10', // stylesheet location
            center: [-66.700, 18.2208], // starting position
            zoom: 8.5 // starting zoom
        });

        // Navigation Control
        var nav = new mapboxgl.NavigationControl();
        map.addControl(nav, 'top-right');

        // *********************************************************************
        // Variable & Object Declaration
        // *********************************************************************

        // List which holds all the known dropoff locations on the map.
        var dropcoor = turf.featureCollection([]);
        var dropoffLocations= turf.featureCollection([]);
        var dropoffPopup = turf.featureCollection([]);
        var blank = turf.featureCollection([]);
        var popups= [];
        var trucks = [];
        var popuproute;
        var truckSelected;
        var HTML_Table = '<table>'
        var maxCluster = 0
        var Colors = ['#ff0000', '#00ff00', '#0000ff', '#008000', '#800000', '#FFFF00',
                      '#808080', '#00ffFF', '#FFFFFF', '#800080', '#008080', '#000080']
        var clusterList=[]
        var id=1;
        // *********************************************************************
        // Objects
        // *********************************************************************

        // initialize an object for the truck.
        var Truck = function(_location, _maxLoad, _routeColor){
            this.id=id++
            this.location = _location;          //initial location of truck
            this.maxLoad = _maxLoad;            //maximum weight that truck can handle
            this.currentLoad = _maxLoad;        //current weight that truck is handling
            this.routeWeight = 0;    //time it takes the route to complete
            this.markedDropoff = turf.featureCollection([]);
            this.waypoints= [];
            this.route= [];
            this.marker = document.createElement('div');
            this.marker.classList = 'truck';
            this.routeMile;
            this.color= _routeColor;
            this.routeColor= {'line-color':this.color , 'line-width':4};

            this.truckMarker = new mapboxgl.Marker(this.marker)
                .setLngLat(this.location)
                .addTo(map);

            this.updateLoad = load => {
                if((this.currentLoad - load) >= 0){this.currentLoad = this.currentLoad - load;}
                else{alert('Not enought load in truck');}
            };

            this.freeLoad= load =>{this.currentLoad= this.currentLoad + load;}
            this.updateRouteWeight = function(routeDurability){
                // routeDurability will contain data.trips[0].duration which contains
                // the time expected in seconds
                this.routeWeight = Math.round(routeDurability/60)
            }
        };

        // *********************************************************************
        // Functions Declaration
        // *********************************************************************
        function allRoute(){
            var allMarkedDropoff = turf.featureCollection([]);
            trucks.forEach(truck => {
                map.setPaintProperty('route'+truck.id, 'line-opacity', 1)
                truck.markedDropoff.features.forEach(md  =>{
                    allMarkedDropoff.features.push(md);
                })
            })

            for(var i = 0; i<=maxCluster;i++){map.getSource('unmarked-dropoff'+i).setData(clusterList[i]);}
            map.getSource('marked-dropoff').setData(allMarkedDropoff);
        }

        function CreateRoute(trucks, map){
            var HTML_Route_Info = '';
            HTML_Route_Info += '<h2> Creating New Route <button style="display: inline-block;background-color:#FFFFFF;color:#000000; border: none;margin-left: 130px;cursor:pointer; "onClick="HTMLTable(trucks, map)">&#10799;</button> </h2>'; 
            HTML_Route_Info += '<div> select starting point for the truck';
            HTML_Route_Info += '<select id="location" type="number">'
            HTML_Route_Info += '<option value="-66.06988906860352,18.44834670293207">San Juan</option>';
            HTML_Route_Info += '<option value="-66.61336898803711,18.011222694738315">Ponce</option>';
            HTML_Route_Info += '<option value="-65.65635681152344,18.316070168322522">Fajardo</option>';
            HTML_Route_Info += '<option value="-67.14088439941406,18.200326726582748">Mayaguez</option>';
            HTML_Route_Info += '<option value="-65.95727920532227,18.381732413643864">Carolina</option>';
            HTML_Route_Info += '<option value="-66.03469848632812,18.231307879658043">Caguas</option>';
            HTML_Route_Info += '</select></div>';
            HTML_Route_Info += '<div>Pick the Route Color: <input type="color" id="RouteColor" value="#'+Math.floor(Math.random()*16777215).toString(16)+'"></div>';           
            HTML_Route_Info += '<div>Max load of the truck: <input type="number" id="MaxLoad" min="1" value=50></div>'
            
            HTML_Route_Info += '<button class="button" type="button" style="background-color:#4CAF50" onClick="AddRoute()">Add Truck to Map</button>'
            document.getElementById('pd').innerHTML = HTML_Route_Info
            document.getElementById("RouteColor").innerHTML ='#'+Math.floor(Math.random()*16777215).toString(16);
        }

        // When Selecting a truck, this will be the menu that will display. It displays information
        // about the route that was selected(soon directions of the route)
        function HTMLDirections(truck, id, trucks, map){
            var HTML_Directions = '';
            HTML_Directions += '<button style="display:inline-block;'
            HTML_Directions +=' vertical-align: middle;'
            HTML_Directions +=' margin:0px;'
            HTML_Directions +=' padding: 0;'
            HTML_Directions +=' border: none;'
            HTML_Directions +=' background: none;'
            HTML_Directions +=' font-size : 50px"'
            HTML_Directions +=' type="button" onclick="HTMLTable(trucks, map)" class="previous">&#8249; </button>'
            HTML_Directions +=' <h3 style="display:inline-block; vertical-align: middle; margin:0px 130px">  Route '+(id+1) +'</h3>' 
            HTML_Directions += '<div> Current Load: ' + truck.currentLoad + '</div>'      
            HTML_Directions += '<div> '+ 'ETA: '+Math.floor(truck.routeWeight/60)+':'          
            HTML_Directions +=                  (Math.floor(truck.routeWeight%60)<10?'0':'')
            HTML_Directions +=                   Math.floor(truck.routeWeight%60)+' hrs</div> '
            HTML_Directions +=  '<div> Stops: ' + truck.markedDropoff.features.length + '</div>'
            waypoints = 'https://www.google.com/maps/dir/'
            truck.waypoints.forEach(location=> {waypoints += location[1] +','+ location[0] +'/'})
            if (truck.waypoints.length){waypoints += truck.waypoints[0][1] +','+ truck.waypoints[0][0] +'/'}
            HTML_Directions += '<div><a class="button" href='+waypoints+' target="_blank">Navigate</Navigate></a></div>'
            HTML_Directions += '<button class="button" type="button" style="background-color:#FF0000" onClick="HTMLRemoveAuth()">Remove Route</button>'

            document.getElementById('pd').innerHTML = HTML_Directions
        }

        // On the main menu of the ui, this HTML will be displayed
        function HTMLTable(trucks, map){
            // HTMLegend(map);
            truckSelected=undefined;
            HTML_Table = '<table>'
            var parameter = trucks +','+ map;
             for(var i = 0; i < trucks.length ; i++){
                HTML_Table+='<tr>'
                HTML_Table+=    '<th rowspan="3" bgcolor='+trucks[i].color+' onclick="SelectTruck('+i+')">Route '+ (i+1) +'</th>'
                HTML_Table+=    '<td>Current Load: '+trucks[i].currentLoad+'</td>'
                HTML_Table+='</tr>'
                HTML_Table+='<tr>'
                HTML_Table+=    '<td>'
                HTML_Table+=        'ETA: '+Math.floor(trucks[i].routeWeight/60)+':'
                HTML_Table+=        (Math.floor(trucks[i].routeWeight%60)<10?'0':'')
                HTML_Table+=        Math.floor(trucks[i].routeWeight%60)+' hrs'
                HTML_Table+=    '</td>'
                HTML_Table+='</tr>'
                HTML_Table+='<tr>'
                HTML_Table+=    '<td>Stops: '+ trucks[i].markedDropoff.features.length +'</td>'
                HTML_Table+= '</tr>';
            }
            HTML_Table += '</table>'
            HTML_Table += '<button class="button" type="button" style="background-color:#4CAF50" onClick="CreateRoute(trucks, map)">Add Route</button>'
            document.getElementById('pd').innerHTML = HTML_Table
            trucks.forEach(truck => {

                truck.truckMarker.addTo(map)
            })
            if(trucks.length!=0){allRoute()};
        }

        // This function will get the markedDropoff variable and feed it to the optimization API 
        // which will return the optimized route for the truck.
        function getRouteMarked(route, truck){

            var destinations = [];
            route.features.forEach(Geometry => {
                destinations.push(Geometry.geometry.coordinates);
             });
            return 'https://api.mapbox.com/optimized-trips/v1/mapbox/driving/' + truck.location[0] + ',' + truck.location[1] + ';'
                    + destinations.join(';') + '?overview=full&steps=true&geometries=geojson&source=first&access_token='
                    + mapboxgl.accessToken;
        };

        // This functions creates the URL to update the dropoff locations with the time that will
        // take to be added to the route.
        function getRouteWeight(route, truck){

            var destinations = [];
            route.forEach(function(Geometry){
                destinations.push(Geometry.geometry.coordinates);
             });
            return 'https://api.mapbox.com/optimized-trips/v1/mapbox/driving/' + truck.location[0] + ',' + truck.location[1] + ';'
                    + destinations.join(';') + '?overview=full&steps=true&geometries=geojson&source=first&access_token='
                    + mapboxgl.accessToken;
        };

        // This function will get the information returned from the getRoute and use it to draw
        // the optimized truck route on the map.
        function drawRoute(truck){
            fetch(getRouteMarked(truck.markedDropoff, truck))
            .then(res => {return res.json()})
            .then(data => {
                var route = (data.trips[0].geometry);
                truck.APIData= data;
                truck.routeMile= data.trips[0].distance/1609.344;
                truck.updateRouteWeight(data.trips[0].duration);
                map.getSource('route').setData(route);
                
            })
            .then(nothing => {
               
                var id;
                for(var i =0; i< trucks.length;i++){
                    if(trucks[i]==truckSelected){
                        var id = i
                    }
                }
                HTMLDirections(truck, id)
                
            })
        };

        // This functions calls the optimization api to calculate the time that will add to each dropoff 
        function updateTruckWeight(drop, truck){
            var copyMarked = truck.markedDropoff.features.slice(0);
            copyMarked.push(drop)
            fetch(getRouteWeight(copyMarked, truck))
            .then(res =>{return res.json();})
            
            .then(data =>{
                var newWeight = Math.round(data.trips[0].duration/60) - truck.routeWeight;
                drop.properties.weight = newWeight;
                drop.properties.color = colorCalculator(drop.properties);
                return drop;
            })
            
            .then(feature =>{
                createPopup(feature);
                dropoffLocations.features.forEach(function(dropoff){
                    if(dropoff.properties.name == feature.properties.name){
                        dropoff.properties.weight = feature.properties.weight;
                    }
                map.getSource(drop.layer.source).setData(dropoffLocations);
                })
            })
        };

        // Function that is called when the Add Route Button is added. For now it adds a marker
        // to the map within a bounding box. and create a truck object.
        function AddRoute(){
                var location = document.getElementById('location').value;
                location = location.split(",")
                var x = parseFloat(location[0])
                var y = parseFloat(location[1])
                
                var RouteColor = document.getElementById('RouteColor').value;
                var MaxLoad = document.getElementById('MaxLoad').value;

                var tmp= new Truck([x, y], MaxLoad, RouteColor);
                trucks.push(tmp);
                map.addLayer({
                  id:'route'+tmp.id,
                  type: 'line',
                  source:{data: blank,type: 'geojson'},
                  paint: tmp.routeColor
                }, 'marked-dropoff'); // change from 'unmarked-dropoff' to 'marked-dropoff'

                map.on('mouseover', 'route'+tmp.id, e => {

                    // check is cursor is hovering over route
                    var routeLocation =  map.queryRenderedFeatures(e.point, {layers: ['route'+tmp.id]});
                    // if hovering on route, create route popup
                    if (routeLocation.length){
                        var pophtml = ''
                        pophtml+= 'Route '+ tmp.id +' Duration<br>'
                        pophtml+= tmp.routeWeight+ ' min' //Think of how to get the correct truck of the route selected.
                        popuproute = new mapboxgl.Popup({ offset: [0, -15], closeButton:false})
                            .setLngLat(e.lngLat)
                            .setHTML(pophtml)
                            .addTo(map);
                    }        
                });
        
                // when the cursor leaves the route, removes route popup.
                map.on('mouseleave', 'route'+tmp.id, e => {popuproute.remove();});
                HTMLTable(trucks, map);
            }


        function SelectTruck(id){
            trucks.forEach(truck => {truck.truckMarker.remove()})
            truckSelected = trucks[id]
            truckSelected.truckMarker.addTo(map)

            HTMLDirections(truckSelected, id)
        }

        // Display automatically the popups of the dropoff within the Radius
        function Radius(_x, _y, truck){
            var centerPoint = {radius:0.16093, x:_x, y:_y}
            dropoffLocations.features.forEach(point =>{
                var pointLocation = {radius: 0.00001, x:point.geometry.coordinates[0], y:point.geometry.coordinates[1]}
                var dx = centerPoint.x - pointLocation.x;
                var dy = centerPoint.y - pointLocation.y;
                if(Math.sqrt(dx*dx + dy*dy) < centerPoint.radius){
                    dropoffPopup.features.push(point)
                    new updateTruckWeight(point, truck)
                }
            })
        };

        // This will look for the clusters that are closest to the truck and create the popup.
        // it could display multiple cluster if the truck is between 2 or more cluster
        function DBScanRadius(truck, points){
            var clusters =[]
            var centerPoint = {radius:0.16093, x:truck.location[0], y:truck.location[1]}
            points.features.forEach(point => {
                var pointLocation = {radius: 0.00001, x:point.geometry.coordinates[0], y:point.geometry.coordinates[1]}
                var dx = centerPoint.x - pointLocation.x;
                var dy = centerPoint.y - pointLocation.y;
                // if(Math.sqrt(dx*dx + dy*dy) < centerPoint.radius){
                //     // display only the cluster close to the truck(intended function)
                // }
        
            })
        };

        // if feature.weight == -1 || feature.weight < dropoff.weight
        // Creates a popup for every dropoff in dropoffLocations.
        function createPopup(feature){
            html= ''
            html+= feature.properties.name+'<br>'
            html+= '<svg height=15 width=20 xmlns="http://www.w3.org/2000/svg" version="1.1">'
            html+= '<circle cx="10" cy="10" r="5" fill="'+feature.properties.color+'"/></svg>'
            html+= '+'+feature.properties.weight+ ' min cluster: '+feature.properties.cluster;
            var popup = new mapboxgl.Popup({ offset: [0, -15], closeButton:false})
                .setHTML(html)
                .setLngLat(feature.geometry.coordinates)
                .addTo(map);
        };

        // This function when given a point, it will check its weight(minutes it takes to drive to the point,
        // and assign it a color depending on its weight. red if the weight is greater than 20, yellow
        // if its between 10 and 19, and green if its less or equal than 10.
        function colorCalculator(dropoff){
            if(dropoff.weight >= 20){
                return '#ff0000';
            }
            else if(dropoff.weight >= 10){
                return '#ffff00';
            }
            else if(dropoff.weight >= 0){
                return '#00ff00';
            }
        };

        // Returns an integer between min(included) & max(excluded)
        function getRndInteger(min, max) {
            return Math.floor(Math.random() * (max - min) ) + min;
        };

        // Returns a float between min(included) & max(excluded)
        function getRndFloat(min, max) {
            return Math.random() * (max - min)  + min;
        };

        // Empty list which will hold all the dropoff locations that were marked on the map.
        // for (var i=0; i<50; i++){
        //     x= getRndFloat(-67.13664550786771, -65.70716270963167)
        //     y= getRndFloat(17.986497494385915, 18.45869548139244)
        //     l= getRndInteger(1, 10);
        //     dropoffLocations.features.push(
        //         turf.point([x, y],
        //         {name: i, load: l, weight: -1, ppop:false, cluster: null, color: ''}));
        // }

        dropoffLocations.features.push(turf.point(
            [-66.2352920, 18.4230130],
            {name: 'Luz N Marrero', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.1717805, 18.4368114],
            {name: 'Betty Rodriguez', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.1932570, 18.4383640],
            {name: 'Janet Villanueva', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0738060, 18.4503860],
            {name: 'Marie Custodio', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.1119410, 18.3727270],
            {name: 'Odalys Rodriguez Matta', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.1252400, 18.3689860],
            {name: 'Alan Wagner', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.1279900, 18.3675350],
            {name: 'Michelle Coll', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.1189290, 18.3623420],
            {name: 'Roberto C. Rodríguez', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0609150, 18.3028000],
            {name: 'Mabel Varela', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0029940, 18.2544850],
            {name: 'Sandra Catalá', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0727820, 18.4502070],
            {name: 'Edward Betancourt', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0825860, 18.4534550],
            {name: 'Vivianna ramirez de arellano', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0158750, 18.4453900],
            {name: 'Gabriela de la Vega', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0665150, 18.4280020],
            {name: 'Tamara Sabalier', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0644510, 18.4053200],
            {name: 'Mila Bravo', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0689100, 18.3755410],
            {name: 'Liz Figueroa', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0641530, 18.3838110],
            {name: 'Doriliana Rivera', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0639040, 18.3486540],
            {name: 'Roxanna Santiago', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.2703290, 18.4750180],
            {name: 'Valerie Alvarado', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0624190, 18.4543770],
            {name: 'Johanna Torres', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0543710, 18.4060870],
            {name: 'Lourdes Orona', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0751680, 18.4576040],
            {name: 'Maria Bartlett', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0640460, 18.4499250],
            {name: 'Tyler Martin', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0252040, 18.4438230],
            {name: 'Melisa Martinez Marti', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.1094300, 18.3814910],
            {name: 'Idabelle Diaz', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0580070, 18.4091790],
            {name: 'Francisco Tirado', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.1144110, 18.3901280],
            {name: 'Carmil S Castro', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0776170, 18.4002420],
            {name: 'Myrnaliz Villafañe ', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.0655610, 18.4462110],
            {name: 'Nicolette Rae Johnson', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        dropoffLocations.features.push(turf.point(
            [-66.1233880, 18.3774160],
            {name: 'Merari Cruz-Loubriel ', load: 1, weight: -1, ppop:false, cluster: null, color: ''}));

        // After the points are created, this will divide them in clusters using DBScan
        // ****************************************************************************
        var dbscanPoints = turf.featureCollection([]);
        dropoffLocations.features.forEach(drop =>{
            dbscanPoints.features.push(turf.point(drop.geometry.coordinates))
        })
        var dbscan = turf.clustersDbscan(dbscanPoints, 13)

        // ****************************************************************************
        // After getting the cluster, the program will start to add to the dropoff to which cluster
        // they belong(0, 1, 2, ..., Noise)
        // **************************************************************************** 
        dbscan.features.forEach(point => {
            if(point.properties.cluster > maxCluster){
                maxCluster = point.properties.cluster
            }
            for(var i = 0; i < dropoffLocations.features.length; i++){
                if(point.geometry.coordinates[0] == dropoffLocations.features[i].geometry.coordinates[0] && point.geometry.coordinates[1] == dropoffLocations.features[i].geometry.coordinates[1]){ 
                    if(point.properties.dbscan == 'noise'){
                        dropoffLocations.features[i].properties.cluster = 'Noise'
                    }
                    else{
                        dropoffLocations.features[i].properties.cluster = point.properties.cluster
                    }
                    break  
                }
            }            
        })

        // ****************************************************************************
        // List will be 0, 1, 2, 3, ..., noise
        // this is intended to create a list to contain all cluster to then be added to the layers
        // that wil be added later in the code
        for(var x = 0; x<maxCluster+1;x++){clusterList.push(turf.featureCollection([]));}

        // adds the drop to their respective clusters
        dropoffLocations.features.forEach(drop => {
            if(drop.properties.cluster == 'Noise'){clusterList[clusterList.length-1].features.push(drop)}
            else{clusterList[drop.properties.cluster].features.push(drop)}
        })

        var layers = []
        for (var i = 0; i<=maxCluster;i++){layers.push('unmarked-dropoff'+i)} 

        // *********************************************************************
        // Mapbox
        // *********************************************************************
        // Map Layers
        // *********************************************************************

        map.on('load', function(){

            // Adds layer with all dropoff locations.
            // Layer that will color each cluster differently to know which color the cluster belong to.
            for(var i = 0; i<=maxCluster;i++){
                if(i<maxCluster){
                    map.addLayer({
                      id: 'unmarked-dropoff'+i,
                      type: 'circle',
                      source: {data: clusterList[i], type: 'geojson'},
                       paint: { "circle-color": Colors[i]}
                      
                    })
                }
                else{
                    map.addLayer({
                      id: 'unmarked-dropoff'+i,
                      type: 'circle',
                      source: {data: clusterList[i], type: 'geojson'},
                       paint: { "circle-color": '#000000'}
                    }) 
                }
                
            }

            // Adds layer with all marked dropoff locations.
            map.addLayer({
              id: 'marked-dropoff',
              type: 'symbol',
              source: {data: blank, type: 'geojson'},
              layout: {
                'icon-allow-overlap': true,
                'icon-ignore-placement': true,
                'icon-image': 'circle-15',
              }
            });

            // Adds layer with the optimized truck route.
            map.addLayer({
              id:'route',
              type: 'line',
              source:{data: blank,type: 'geojson'},
              paint: {
                'line-color': '#0000ff',
                'line-width': 4
              }
            });
        });
        HTMLTable(trucks, map);

        // Events/Listeners
        // *********************************************************************
        
        // when the clicks on the map, checks if a marker was clicked and if true,
        // then change that marker from unmarked to marked or vice-versa.
        var visible = 'none'
        map.on('click',e =>{
            // map.removeLayer('unmarked-dropoff')
            // map.addLayer('unmarked-dropoff')
            if(visible == 'none'){
                visible = 'visible'
                
                    map.setLayoutProperty('route', 'visibility', visible)
            }
            else {
                visible = 'none'
                
                map.setLayoutProperty('route', 'visibility', visible)
            }
            // returns the info of the clicked dropoff marker on map.
            layers.push('marked-dropoff')
            var pt = map.queryRenderedFeatures(e.point, {layers: layers});
            layers.pop()

            // if a marker is clicked, do the following
            if (pt.length && truckSelected != undefined){
                // if the marker is unmarked, do the following
                for(var j = 0;j<layers.length;j++){
                    if(pt[0].layer.id==layers[j]){
                    // looks for the clicked marker in dropoffLocations.
                    for(var i = 0; i < clusterList[j].features.length; i++){
                        // if the clicked marker is found, do the following.
                        if(pt[0].properties.name == clusterList[j].features[i].properties.name){
                            // push the dropoff to markedDropoff.
                            truckSelected.markedDropoff.features.push(clusterList[j].features[i]);
                            // update the truck load.
                            truckSelected.updateLoad(clusterList[j].features[i].properties.load);
                            // remove the dropoff from dropoffLocation, do to it now being marked.
                            clusterList[j].features.splice(i, 1);
                            break;
                        }
                        clusterList[j].features[i].properties.weight = -1;
                    }
                    map.getSource(layers[j]).setData(clusterList[j]);
                }

                // if the marker is marked, do the following
                else{
                    // look the marker in markedDropoff of truckSelected
                    for(var i=0; i<truckSelected.markedDropoff.features.length; i++){
                        // if found, do the following
                        if(pt[0].properties.name == truckSelected.markedDropoff.features[i].properties.name){
                            // check if marked is already in dropoffLocations.
                            var check=0;
                            for(var i=0; i<clusterList[j].features.length; i++){
                                if(pt[0].properties.name == clusterList[j].features[i].properties.name){
                                    check=1;
                                    break;
                                }
                            }

                            // if the marked is not in dropoffLocations, then add it
                            if(check==0){clusterList[j].features.push(pt[0])};

                            // update truckSelected
                            truckSelected.freeLoad(pt[0].properties.load);

                            // remove the dropoff from truckSelected.markedDropoff
                            truckSelected.markedDropoff.features.splice(i, 1);
                            break;
                        }
                    }
                }
                }
                

            }

            // if marker not clicked, change ppop of dropoffLocations to false.
            else{
                for (var i=0; i< dropoffLocations.features.length; i++){
                    dropoffLocations.features[i].properties.ppop=false;
                }
            }
            // update the sources of the layers: 'unmarked-dropoff' & 'marked-dropoff'.
            
            map.getSource('marked-dropoff').setData(truckSelected.markedDropoff);

            // draw the truck route.
            if (truckSelected.markedDropoff.features.length==0){
                map.getSource('route').setData(blank);
                // truckSelected.markedDropoff = turf.featureCollection([]);
            }
            drawRoute(truckSelected);

            //update the weight of the dropoff points in dropoffLocations.
            dropcoor.features.length = 0

            dropcoor.features.push(turf.point([truckSelected.location[0], truckSelected.location[1]]))
            truckSelected.markedDropoff.features.forEach(mark => {
                dropcoor.features.push(turf.point(mark.geometry.coordinates))
            })

            var center = turf.center(dropcoor);
            // var RandomCluster = getRndInteger(0, maxCluster)
            // dbscan.features.forEach(point => {
            //     if(point.properties.cluster == RandomCluster){
            //         new updateTruckWeight(point, truckSelected)
            //     }
            // })

            Radius(center.geometry.coordinates[0], center.geometry.coordinates[1], truckSelected);
        });

        // when the cursor is hovering over the marker, it will change the cursor icon
        // from the grab icon to the pointer icon & create a popup for the dropoff marker.
        for(var i = 0; i<layers.length;i++){
            map.on('mouseover',layers[i], e=> {
            
            var features = map.queryRenderedFeatures(e.point, {layers: layers[i]});
            // if cursor hovers an unmarked dropoff, do the following
                if (features.length) {
                    
                    map.getCanvas().style.cursor='pointer'; // change cursor icon from grab to pointer
                    
                    feature=features[0];
                    // if weight of dropoff is undefined, update it
                    if(feature.properties.weight == -1){
                        updateTruckWeight(feature, truckSelected);
                    }

                    // if the dropoff does not have a popup, do the following
                    else if(feature.properties.ppop == false){

                        feature.properties.color= colorCalculator(feature.properties) // update color of dropoff
                        createPopup(feature);   //create popup for dropoff
                        feature.properties.ppop=true; //change ppop of dropoff

                        // update dropoff in dropoffLocations
                        for (var i=0; i<dropoffLocations.features.length; i++){
                            if(feature.properties.name==dropoffLocations.features[i].properties.name){
                                dropoffLocations.features[i]= feature;
                                break
                            }
                        }

                        // update source of the layer 'unmarked-dropoff'.
                       map.getSource('unmarked-dropoff'+i).setData(dropoffLocations);
                    }
            }
               
            });
            map.on('mouseleave', layers[i], e=> {map.getCanvas().style.cursor=''});
        }
        

        // when the cursor is hovering over the marker, it will change the cursor icon
        // from the grab icon to the pointer icon.
        map.on('mouseover', 'marked-dropoff' , e=>{
            features= map.queryRenderedFeatures(e.point, {layers:['marked-dropoff']});
            if(features.length){map.getCanvas().style.cursor='pointer'};
        })

        // when the cursor leaves the marker, change cursor icon from the pointer icon 
        // to the grab icon.
        map.on('mouseleave', e=> {map.getCanvas().style.cursor=''});
        
        // when the cursor leaves the marker, change cursor icon from the pointer icon 
        // to the grab icon.
        map.on('mouseleave','marked-dropoff' , e=> {map.getCanvas().style.cursor=''});

        // when the cursor is hovering over the route, display a popup with
        // the time it takes the truck to finish the route.
        map.on('mouseover', 'route', e => {

            // check is cursor is hovering over route
            var routeLocation =  map.queryRenderedFeatures(e.point, {layers: ['route']});

            // if hovering on route, create route popup
            if (routeLocation.length){
                var pophtml = ''
                pophtml+= 'Current Route Duration<br>'
                pophtml+= truckSelected.routeWeight+ ' min' //Think of how to get the correct truck of the route selected.
                popuproute = new mapboxgl.Popup({ offset: [0, -15], closeButton:false})
                    .setLngLat(e.lngLat)
                    .setHTML(pophtml)
                    .addTo(map);
            }
        });

        // when the cursor leaves the route, removes route popup.
        map.on('mouseleave', 'route', e => {popuproute.remove()});
    </script>
</body>
</html>